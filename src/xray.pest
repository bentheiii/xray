header = {SOI ~ top_level_execution ~ EOI}
eval = {SOI ~ expression ~ EOI}

top_level_execution = {import* ~ execution}
execution = {declaration*}
declaration = {value | function | struct_def | union_def}
expression = {
    expression1 ~ (BINARY_OP ~ expression1)*
}
expression1 = {
    (UNARY_OP)* ~ expression2
}
expression2 = {
    expression3 ~ ("." ~ CNAME ~ call_args)*
}
 call_args = {
    "(" ~ container_elements? ~ ","? ~ ")"
 }
expression3 = {
    expression4 ~ call_args*
}
expression4 = {
    expression5 ~ generic_arguments_opt ~ ("::" ~ CNAME)*
}
    generic_arguments_opt = { generic_arguments? }
expression5 = _{
    STRING
    | bool
    | NUMBER_ANY
    | container
    | specialized_cname
    | CNAME
    | map
    | "(" ~ expression ~ ")"
}
 container = {container_type_opt ~ "[" ~ container_elements? ~ ","? ~ "]"}
  container_type_opt = { container_type? }
  container_elements = {expression ~ (","~expression)*}
  container_type = {"array" | "set"}
 map = {"{" ~ map_pairs? ~ ","? ~ "}"}
  map_pairs = {map_pair ~ (","~map_pair)*}
  map_pair = {expression ~ ":"~ expression}
 bool = @{"true"|"false"}
 specialized_cname = {CNAME ~ "::<" ~ complete_type ~ (","~complete_type)* ~ ">"}

UNARY_OP = _{UNARY_PLUS | UNARY_MINUS | UNARY_NOT}
 UNARY_PLUS = {"+"}
 UNARY_MINUS = {"-"}
 UNARY_NOT = {"!"}
BINARY_OP = _{BINARY_ADD | BINARY_SUB | BINARY_MUL | BINARY_DIV | BINARY_MOD | BINARY_AND | BINARY_OR | BINARY_EQ
             | BINARY_NE | BINARY_LE | BINARY_GE | BINARY_LT | BINARY_GT | BINARY_BIT_AND | BINARY_BIT_OR
             | BINARY_BIT_XOR}
 BINARY_ADD = {"+"}
 BINARY_SUB = {"-"}
 BINARY_MUL = {"*"}
 BINARY_DIV = {"/"}
 BINARY_POW = {"**"}
 BINARY_AND = {"&&"}
 BINARY_OR = {"||"}
 BINARY_LT = {"<"}
 BINARY_GT = {">"}
 BINARY_LE = {"<="}
 BINARY_GE = {">="}
 BINARY_EQ = {"=="}
 BINARY_NE = {"!="}
 BINARY_MOD = {"%"}
 BINARY_BIT_AND = {"&"}
 BINARY_BIT_OR = {"|"}
 BINARY_BIT_XOR = {"^"}

pub_opt = {"public"?}

import = {pub_opt ~ "import " ~ import_spec ~ ";"}
 import_spec = {CNAME ~ ("::" ~ CNAME)* ~ ("::" ~ import_group)?}
 import_group = {"{" ~ CNAME ~ (", " ~ CNAME)* ~ ","? ~ "}"| "{" ~ ("*"|"**") ~ ","? ~ "}" }

value = {pub_opt ~ "let " ~ CNAME ~ explicit_type_opt ~ "=" ~ expression ~ ";"}
 explicit_type_opt = {explicit_type?}
 explicit_type = _{":" ~ complete_type}

function = {pub_opt ~"fn " ~ CNAME ~ generic_signature_opt ~ "(" ~ function_parameters_opt ~ ","? ~ ")" ~ "->" ~ complete_type ~ function_body}
 generic_signature_opt = { generic_signature? }
 function_body = {"{"~execution~expression~"}" }
 generic_signature = {"<" ~ generic_parameter ~ ("," ~ generic_parameter)* ~ ">"}
 generic_parameter = {CNAME ~ generic_constraint?}
 generic_constraint = {":" ~ complete_type}

 function_parameters_opt = { function_parameters? }
 function_parameters = {(parameter ~ ",")* ~ parameter}
 parameter = {CNAME ~ ":" ~ complete_type ~ default_value?}
 default_value = {"?="~expression}

struct_def = {pub_opt ~ "struct " ~ CNAME ~ generic_signature_opt ~ "(" ~ struct_parameters ~ ")"}
 struct_parameters = {(struct_parameter ~ ",")* ~ struct_parameter ~ ","?}
 struct_parameter = {CNAME ~ ":" ~ complete_type}

union_def = {pub_opt ~ "union " ~ CNAME ~ generic_signature_opt ~ "(" ~ union_parameters ~ ","? ~ ")"}
 union_parameters = {(union_parameter ~ ",")* ~ union_parameter}
 union_parameter = {CNAME ~ ":" ~ complete_type}

complete_type = {
  CNAME ~ generic_arguments?
  | signature
 }
 generic_arguments = {"<" ~ (complete_type ~ ",")* ~ complete_type ~ ">"}
 signature = {"(" ~ param_specs_opt ~ ")" ~ "->" ~ "(" ~ complete_type ~ ")"}
 param_specs_opt = { param_specs? }
 param_specs = {(complete_type ~ ",")* ~ complete_type}

CNAME = @{("_" | ASCII_ALPHA) ~ ("_" | ASCII_ALPHANUMERIC)*}

NUMBER_ANY = @{num | hexnum | binnum}
num = { int ~ ("." ~ num_digit*)? ~ (^"e" ~ int)? }
 int = { num_digit+ }
 num_digit = {ASCII_DIGIT|"_"}
hexnum = { "0x" ~ hex_digit+ }
 hex_digit = {ASCII_HEX_DIGIT|"_"}
binnum = { "0b" ~ bin_digit+ }
 bin_digit = {"0"|"1"|"_"}

STRING = {PUSH("#"*) ~ "'" ~ inner_string ~ "'" ~ POP}
 inner_string = @{(!("'" ~ PEEK)~ ANY)*}

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!NEWLINE ~ ANY)* ~ NEWLINE) }